<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Robert Utterback | Publications</title>
<meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
">

     <link rel="shortcut icon" href="https://robertutterback.github.io/assets/img/favicon.ico">
		 <link rel="stylesheet" href="https://robertutterback.github.io/assets/css/main.css">
		 <!-- <link rel="shortcut icon" href="/assets/img/favicon.ico"> -->
     <!-- <link rel="stylesheet" href="/assets/css/main.css"> -->

     <link rel="canonical" href="https://robertutterback.github.io/pubs/">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    
    <span class="site-title">
        
        <strong>Robert</strong> Utterback
    </span>
    

    <nav class="site-nav">

      <div class="trigger">
        <!-- About -->
        <a class="page-link" href="https://robertutterback.github.io/">About</a>
        <!-- <a class="page-link" href="">About</a> -->

        <!-- Blog -->
        <!-- <a class="page-link" href="https://robertutterback.github.io/blog/">blog</a> -->

        <!-- Pages -->
        
          
        
          
						 <a class="page-link" href="https://robertutterback.github.io/cv/">CV</a>
						 <!-- <a class="page-link" href="">CV</a> -->
          
        
          
        
          
        
          
						 <a class="page-link" href="https://robertutterback.github.io/pubs/">Publications</a>
						 <!-- <a class="page-link" href="">Publications</a> -->
          
        
          
						 <a class="page-link" href="https://robertutterback.github.io/resources/">Resources</a>
						 <!-- <a class="page-link" href="">Resources</a> -->
          
        
          
						 <a class="page-link" href="https://robertutterback.github.io/schedule/">Schedule</a>
						 <!-- <a class="page-link" href="">Schedule</a> -->
          
        
          
						 <a class="page-link" href="https://robertutterback.github.io/teaching/">Teaching</a>
						 <!-- <a class="page-link" href="">Teaching</a> -->
          
        
          
        

        <!-- CV link -->
        <!-- <a class="page-link" href="https://robertutterback.github.io/assets/pdf/cv.pdf">Vitae</a> -->

      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Publications</h1>
		<h5 class="post-description">Publications in reversed chronological order. Generated by jekyll-scholar.</h5>
  </header>

	<article class="post-content Publications clearfix">
		
<h3 class="year">2023</h3>
<ol class="bibliography"><li>

<div id="bti-journal">
  
    <span class="title"><a href="https://onlinelibrary.wiley.com/doi/abs/10.1111/imig.13110">Migration narratives in Northern Triangle, Mexican and US media from 1999 to 2019</a></span>
    <span class="author">
      
      
        
          
            
              <a href="https://faculty.af.edu/esploro/profile/robert_hinck/overview" target="_blank">Hinck, Robert S.</a>,
            
          
        
      
        
          
            <em>Utterback, Robert</em>,
          
        
      
        
          
            
              Kitsch, Sara R.,
            
          
        
      
        
          and
          
            
              Wenzel, Sarah
            
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>International Migration</em>
    
    
      2023
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Abstract This study conceptualizes the mediated discussions of migration in Central America as narratives, arguing for the need to examine the broader contours of policy-related migration reporting across time. Using machine learning and text mining analyses, combined with qualitative narrative analysis, the study examines 53,441 news articles from 17 US, Mexican and Northern Triangle media outlets from 1999 to 2019, tracing and critiquing the shifts in coverage. Findings suggest that all three media systems generally align in their depiction of the scene, key agents and acts regarding migration; however, US narratives increasingly diverge from Northern Triangle and Mexican narratives regarding the purpose and instruments by which migration occurs, with US value claims narrowing over time emphasizing border security. This narrative trajectory within US media ignores migrants’ determination and underlining rationales for migration, pushing them to take increasingly dangerous means to migrate to the USA and exacerbating the situation for all parties.</p>
  </span>
  
</div>
</li></ol>

<h3 class="year">2021</h3>
<ol class="bibliography"><li>

<div id="bti-confpaper">
  
    <span class="title"><a href="">Transforming Media Narratives on Migration: Narrative Divergence within Northern Triangle, Mexican, and US News Reporting on Migration from 1999-2019</a></span>
    <span class="author">
      
      
        
          
            
              <a href="https://faculty.af.edu/esploro/profile/robert_hinck/overview" target="_blank">Hinck, R. S.</a>,
            
          
        
      
        
          
            
              Kitsch, S. R.,
            
          
        
      
        
          
            <em>Utterback, R.</em>,
          
        
      
        
          and
          
            
              Wenzel, S.
            
          
        
      
      
    </span>

    <span class="periodical">
    
       <em>Paper presented at the 2021 National Communication Association Annual Conference, Seattle, WA 2021</em><br />
    
    
      2021
    
    </span>
  

  <span class="links">
  <!--  -->
  
  
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
</div>
</li>
<li>

<div id="bti-report">
  
    <span class="title"><a href="https://mesagroup.okstate.edu/news/390-research-report-mexican-and-northern-triangle-perspectives-on-migration-identifying-and-assessing-strategic-narrative-alignment">Mexican and Northern Triangle Perspectives on Migration: Identifying and Assessing Strategic Narrative Alignment</a></span>
    <span class="author">
      
        
        
        <a href="https://mesagroup.okstate.edu/">Media Ecology &amp; Strategic Analysis (MESA) Group</a> (Skye Cooley, Robert Hinck, Asya Cooley, Sara Kitsch, Robert Utterback, Jared Johnson)
        
      
    </span>

    <span class="periodical">
    
       <em>Prepared for the U.S. Department of Homeland Security</em><br />
    
    
      2021
    
    </span>
  

  <span class="links">
  <!--  -->
  
  
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
</div>
</li></ol>

<h3 class="year">2019</h3>
<ol class="bibliography"><li>

<div id="sma2019">
  
    <span class="title"><a href="https://nsiteam.com/jammu-and-kashmir-reach-back-media-analysis-of-extremist-activities-in-indian-and-pakistani-news/">Jammu and Kashmir Reach Back: Media Analysis of Extremist Activities in Indian and Pakistani News</a></span>
    <span class="author">
      
      
        
          
            
              Cooley, Skye,
            
          
        
      
        
          
            
              <a href="https://faculty.af.edu/esploro/profile/robert_hinck/overview" target="_blank">Hinck, Robert</a>,
            
          
        
      
        
          and
          
            <em>Utterback, Robert</em>
          
        
      
      
    </span>

    <span class="periodical">
    
       <em>A Media Ecology &amp; Strategic Analysis (MESA) Group Report</em><br />
    
    
      2019
    
    </span>
  

  <span class="links">
  <!--  -->
  
  
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
</div>
</li>
<li>

<div id="futurerace">
  
    <span class="title"><a href="http://doi.acm.org/10.1145/3293883.3295732">Efficient Race Detection with Futures</a></span>
    <span class="author">
      
      
        
          
            <em>Utterback, Robert</em>,
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~kunal/" target="_blank">Agrawal, Kunal</a>,
            
          
        
      
        
          
            
              <a href="http://people.cs.georgetown.edu/~jfineman/" target="_blank">Fineman, Jeremy</a>,
            
          
        
      
        
          and
          
            
              <a href="http://www.cse.wustl.edu/~angelee/" target="_blank">Lee, I-Ting Angelina</a>
            
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>In Proceedings of the 24th Symposium on Principles and Practice of Parallel Programming</em>
    
    
      2019
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
    [<a href="https://robertutterback.github.io/assets/pdf/futurerace.pdf" target="_blank">PDF</a>]
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>This paper addresses the problem of provably efficient and practically good on-the-fly determinacy race detection in task parallel programs that use futures. Prior works on determinacy race detection have mostly focused on either task parallel programs that follow a series-parallel dependence structure or ones with unrestricted use of futures that generate arbitrary dependences. In this work, we consider a restricted use of futures and show that we can detect races more efficiently than with general use of futures.

Specifically, we present two algorithms: MultiBags and MultiBags+. MultiBags targets programs that use futures in a restricted fashion and runs in time O(T1α(m, n)), where T1 is the sequential running time of the program, α is the inverse Ackermann’s function, m is the total number of memory accesses, n is the dynamic count of places at which parallelism is created. Since α is a very slowly growing function (upper bounded by 4 for all practical purposes), it can be treated as a close-to-constant overhead. MultiBags+ is an extension of MultiBags that target programs with general use of futures. It runs in time O((T1 + k2)α(m, n)) where T1, α, m and n are defined as before, and k is the number of future operations in the computation. We implemented both algorithms and empirically demonstrate their efficiency.</p>
  </span>
  
</div>
</li>
<li>

<div id="porridge-topc">
  
    <span class="title"><a href="https://doi.org/10.1145/3365659">Processor-Oblivious Record and Replay</a></span>
    <span class="author">
      
      
        
          
            <em>Utterback, Robert</em>,
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~kunal/" target="_blank">Agrawal, Kunal</a>,
            
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~angelee/" target="_blank">Lee, I-Ting Angelina</a>,
            
          
        
      
        
          and
          
            
              <a href="https://engineering.purdue.edu/~milind/" target="_blank">Kulkarni, Milind</a>
            
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>ACM Trans. Parallel Comput.</em>
    
    
      2019
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Record-and-replay systems are useful tools for debugging non-deterministic parallel programs by first recording an execution and then replaying that execution to produce the same access pattern. Existing record-and-replay systems generally target thread-based execution models, and record the behaviors and interleavings of individual threads. Dynamic multithreaded languages and libraries, such as the Cilk family, OpenMP, TBB, and the like, do not have a notion of threads. Instead, these languages provide a processor-oblivious model of programming, where programs expose task parallelism using high-level constructs such as spawn/sync without regard to the number of threads/cores available to run the program. Thread-based record-and-replay would violate the processor-oblivious nature of these programs, as they incorporate the number of threads into the recorded information, constraining the replayed execution to the same number of threads.

In this article, we present a processor-oblivious record-and-replay scheme for dynamic multithreaded languages where record and replay can use different number of processors and both are scheduled using work stealing. We provide theoretical guarantees for our record and replay scheme—namely that record is optimal for programs with one lock and replay is near-optimal for all cases. In addition, we implemented this scheme in the Cilk Plus runtime system and our evaluation indicates that processor-obliviousness does not cause substantial overheads.</p>
  </span>
  
</div>
</li></ol>

<h3 class="year">2018</h3>
<ol class="bibliography"><li>

<div id="nearlysp">
  
    <span class="title"><a href="http://epubs.siam.org/doi/abs/10.1137/1.9781611975031.11">Race Detection and Reachability in Nearly Series-Parallel
                  DAGs</a></span>
    <span class="author">
      
      
        
          
            
              <a href="http://www.cse.wustl.edu/~kunal/" target="_blank">Agrawal, Kunal</a>,
            
          
        
      
        
          
            
              Devietti, Joseph,
            
          
        
      
        
          
            
              <a href="http://people.cs.georgetown.edu/~jfineman/" target="_blank">Fineman, Jeremy T.</a>,
            
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~angelee/" target="_blank">Lee, I-Ting Angelina</a>,
            
          
        
      
        
          
            <em>Utterback, Robert</em>,
          
        
      
        
          and
          
            
              Xu, Changming
            
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>In Proceedings of the Twenty-Ninth Annual ACM-SIAM
                  Symposium on Discrete Algorithms</em>
    
    
      2018
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
    [<a href="https://robertutterback.github.io/assets/pdf/nearlsp.pdf" target="_blank">PDF</a>]
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>A program is said to have a determinacy race if logically parallel parts of a program access the same memory location and one of the accesses is a write. These races are generally bugs in the program since they lead to non-deterministic program behavior — different schedules of the program can lead to different results. Most prior work on detecting these races focuses on a subclass of programs with series-parallel or nested parallelism.

This paper presents a race-detection algorithm for detecting races in a more general class of programs, namely programs that include arbitrary ordering constraints in additional to the series-parallel constructs. The algorithm performs a serial execution of the program, augmented to detect races, in O(T1 + k2) time, where T1 is the sequential running time of the original program and k is the number of non series-parallel constraints.

The main technical novelty of this paper is a new data structure, R-Sketch, for answering reachability queries in nearly series-parallel (SP) directed acyclic graphs (DAGs). Given as input a graph comprising an n-node series parallel graph and k additional non-SP edges, the total construction time of the data structure is O(n + k2), and each reachability query can be answered in O(1) time. The data structure is traversally incremental, meaning that it supports the insertion of nodes/edges, but only as they are discovered through a graph traversal.</p>
  </span>
  
</div>
</li></ol>

<h3 class="year">2017</h3>
<ol class="bibliography"><li>

<div id="porridge">
  
    <span class="title"><a href="http://doi.acm.org/10.1145/3018743.3018764">Processor-Oblivious Record and Replay</a></span>
    <span class="author">
      
      
        
          
            <em>Utterback, Robert</em>,
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~kunal/" target="_blank">Agrawal, Kunal</a>,
            
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~angelee/" target="_blank">Lee, I-Ting Angelina</a>,
            
          
        
      
        
          and
          
            
              <a href="https://engineering.purdue.edu/~milind/" target="_blank">Kulkarni, Milind</a>
            
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>In Proceedings of the 22nd ACM SIGPLAN Symposium on
                  Principles and Practice of Parallel Programming</em>
    
    
      2017
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
    [<a href="https://robertutterback.github.io/assets/pdf/porridge.pdf" target="_blank">PDF</a>]
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Record-and-replay systems are useful tools for debugging non-deterministic parallel programs by first recording an execution and then replaying that execution to produce the same access pattern. Existing record-and-replay systems generally target thread-based execution models, and record the behaviors and interleavings of individual threads. Dynamic multithreaded languages and libraries, such as the Cilk family, OpenMP, TBB, etc., do not have a notion of threads. Instead, these languages provide a processor-oblivious model of programming, where programs expose task-parallelism using high-level constructs such as spawn/sync without regard to the number of threads/cores available to run the program. Thread-based record-and-replay would violate the processor-oblivious nature of these programs, as they incorporate the number of threads into the recorded information, constraining the replayed execution to the same number of threads.

In this paper, we present a processor-oblivious record-and-replay scheme for such languages where record and replay can use different number of processors and both are scheduled using work stealing. We provide theoretical guarantees for our record and replay scheme — namely that record is optimal for programs with one lock and replay is near-optimal for all cases. In addition, we implemented this scheme in the Cilk Plus runtime system and our evaluation indicates that processor-obliviousness does not cause substantial overheads.</p>
  </span>
  
</div>
</li></ol>

<h3 class="year">2016</h3>
<ol class="bibliography"><li>

<div id="cracer">
  
    <span class="title"><a href="http://doi.acm.org/10.1145/2935764.2935801">Provably Good and Practically Efficient Parallel
                  Race Detection for Fork-Join Programs</a></span>
    <span class="author">
      
      
        
          
            <em>Utterback, Robert</em>,
          
        
      
        
          
            
              <a href="http://www.cse.wustl.edu/~kunal/" target="_blank">Agrawal, Kunal</a>,
            
          
        
      
        
          
            
              <a href="http://people.cs.georgetown.edu/~jfineman/" target="_blank">Fineman, Jeremy T.</a>,
            
          
        
      
        
          and
          
            
              <a href="http://www.cse.wustl.edu/~angelee/" target="_blank">Lee, I-Ting Angelina</a>
            
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>In Proceedings of the 28th ACM Symposium on Parallelism
                  in Algorithms and Architectures</em>
    
    
      2016
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
    [<a href="https://robertutterback.github.io/assets/pdf/cracer.pdf" target="_blank">PDF</a>]
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>If a parallel program has determinacy race(s), different schedules can result in memory accesses that observe different values — various race-detection tools have been designed to find such bugs. A key component of race detectors is an algorithm for series-parallel (SP) maintenance, which identifies whether two accesses are logically parallel. This paper describes an asymptotically optimal algorithm, called WSP-Order, for performing SP maintenance in programs with fork-join (or nested) parallelism. Given a fork-join program with T1 work and T∞ span, WSP-Order executes it while also maintaining SP relationships in O(T1/P + T∞) time on P processors, which is asymptotically optimal. At the heart of WSP-Order is a work-stealing scheduler designed specifically for SP maintenance.

We also implemented C-RACER, a race-detector based on WSP-Order within the Cilk Plus runtime system, and evaluated its performance on five benchmarks. Empirical results demonstrate that when run sequentially, it performs almost as well as previous best sequential race detectors. More importantly, when run in parallel, it achieves almost as much speedup as the original program without race-detection.</p>
  </span>
  
</div>
</li></ol>

<h3 class="year">2014</h3>
<ol class="bibliography"><li>

<div id="batcher">
  
    <span class="title"><a href="http://doi.acm.org/10.1145/2612669.2612688">Provably Good Scheduling for Parallel Programs That
                  Use Data Structures Through Implicit Batching</a></span>
    <span class="author">
      
      
        
          
            
              <a href="http://www.cse.wustl.edu/~kunal/" target="_blank">Agrawal, Kunal</a>,
            
          
        
      
        
          
            
              <a href="http://people.cs.georgetown.edu/~jfineman/" target="_blank">Fineman, Jeremy T.</a>,
            
          
        
      
        
          
            
              Lu, Kefu,
            
          
        
      
        
          
            
              Sheridan, Brendan,
            
          
        
      
        
          
            
              Sukha, Jim,
            
          
        
      
        
          and
          
            <em>Utterback, Robert</em>
          
        
      
      
    </span>

    <span class="periodical">
    
      <em>In Proceedings of the 26th ACM Symposium on Parallelism
                  in Algorithms and Architectures</em>
    
    
      2014
    
    </span>
  

  <span class="links">
  <!--  -->
  <!--   [<a class="abstract">Abs</a>] -->
  <!--  -->
  
  
  
    [<a href="https://robertutterback.github.io/assets/pdf/batcher.pdf" target="_blank">PDF</a>]
  
  
  
  
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Although concurrent data structures are commonly used in practice on shared-memory machines, even the most efficient concurrent structures often lack performance theorems guaranteeing linear speedup for the enclosing parallel program. Moreover, efficient concurrent data structures are difficult to design. In contrast, parallel batched data structures do provide provable performance guarantees, since processing a batch in parallel is easier than dealing with the arbitrary asynchrony of concurrent accesses. They can limit programmability, however, since restructuring a parallel program to use batched data structure instead of concurrent data structure can often be difficult or even infeasible.

This paper presents BATCHER, a scheduler that achieves the best of both worlds through the idea of implicit batching, and a corresponding general performance theorem. BATCHER takes as input (1) a dynamically multithreaded program that makes arbitrary parallel accesses to an abstract data type, and (2) an implementation of the abstract data type as a batched data structure that need not cope with concurrent accesses. BATCHER extends a randomized work-stealing scheduler and guarantees probably good performance to parallel algorithms that use these data structures. In particular, suppose a parallel algorithm has (i)T_1(i/) work, (I)T_∞(I/) span, and (I)n(I/) data-structure operations. Let (I)W(n)(I/) be the total work of data-structure operations and let (I)s(n)(I/) be the span of a size-(I)P(I/) batch. Then BATCHER executes the program in (I)O((T_1+W(n) + n s(n))/P+ s(n) T_∞)(I/) expected time on (I)P(I/) processors. For higher-cost data structures like search trees and large enough (I)n(I/), this bound becomes (I)(T_1+n\lg n)/P + T_∞lg n)(I/) provably matching the work of a sequential search tree but with nearly linear speedup, even though the data structure is accessed concurrently. The BATCHER runtime bound also readily extends to data structures with amortized bounds.</p>
  </span>
  
</div>
</li></ol>


	</article>

	

	


</div>

      </div>
    </div>

    <footer>

  <div class="wrapper">
    &copy; Copyright 2025 Robert Utterback.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    
  </div>

</footer>


    <!-- Load jQuery -->
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>

<!-- Load Common JS -->
<script src="https://robertutterback.github.io/assets/js/common.js"></script>


<!-- Load KaTeX -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
<!-- <script src="/assets/js/katex.js"></script> -->
<script src="https://robertutterback.github.io/assets/js/katex.js"></script>




<!-- Include custom icon fonts -->
<link rel="stylesheet" href="https://robertutterback.github.io/assets/css/font-awesome.min.css">
<link rel="stylesheet" href="https://robertutterback.github.io/assets/css/academicons.min.css">

<!-- <link rel="stylesheet" href="/assets/css/font-awesome.min.css"> -->
<!-- <link rel="stylesheet" href="/assets/css/academicons.min.css"> -->


<!-- Google Analytics -->
<!-- <script> -->
<!-- (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ -->
<!-- (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), -->
<!-- m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) -->
<!-- })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); -->

<!-- ga('create', 'UA-XXXXXXXX-X', 'auto'); -->
<!-- ga('send', 'pageview'); -->
<!-- </script> -->


  </body>

</html>
